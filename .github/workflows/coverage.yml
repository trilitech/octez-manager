name: Coverage Report

on:
  pull_request:
    branches: [main]
    types: [opened, synchronize, reopened, labeled, unlabeled]
  push:
    branches: [main]

concurrency:
  group: coverage-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  pull-requests: write

jobs:
  coverage:
    name: Generate Coverage Report
    runs-on: ubuntu-latest
    # TODO: Re-enable conditional after testing
    # if: |
    #   github.event_name == 'push' || 
    #   contains(github.event.pull_request.labels.*.name, 'coverage') ||
    #   github.event.action == 'opened'
    container:
      image: ghcr.io/${{ github.repository }}-ci-debian:latest
      credentials:
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
      options: --tty  # Allocate a pseudo-TTY for UI tests
    env:
      OPAMYES: "true"
      MIAOU_GIT_URL: ${{ secrets.MIAOU_GIT_URL }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Need full history for coverage comparison

      - name: Cache opam packages
        id: cache-opam
        uses: actions/cache@v4
        with:
          path: /root/.opam
          key: opam-debian-miaou-${{ hashFiles('.github/miaou-version') }}

      - name: Ensure opam is initialized
        id: opam-init
        run: |
          # Check if opam actually works, not just if directory exists
          if opam switch list 2>&1 | grep -q "5.3.0"; then
            echo "Opam switch 5.3.0 exists, using it..."
            echo "needs_miaou=false" >> $GITHUB_OUTPUT
            eval $(opam env)
          else
            echo "Initializing opam and creating switch 5.3.0..."
            opam init --disable-sandboxing --bare -y || true
            opam switch create 5.3.0 ocaml.5.3.0 -y
            echo "needs_miaou=true" >> $GITHUB_OUTPUT
            eval $(opam env)
          fi

      - name: Pin miaou packages
        if: steps.cache-opam.outputs.cache-hit != 'true' || steps.opam-init.outputs.needs_miaou == 'true'
        run: |
          if [ -z "$MIAOU_GIT_URL" ]; then
            echo "ERROR: MIAOU_GIT_URL secret is not configured." >&2
            exit 1
          fi
          eval $(opam env)
          opam pin add miaou-core "$MIAOU_GIT_URL" --no-action
          opam pin add miaou-driver-term "$MIAOU_GIT_URL" --no-action
          opam pin add miaou-driver-matrix "$MIAOU_GIT_URL" --no-action
          opam pin add miaou-runner "$MIAOU_GIT_URL" --no-action
          opam install miaou-core miaou-driver-term miaou-driver-matrix miaou-runner eio_posix

      - name: Install project dependencies
        run: |
          eval $(opam env)
          git config --global --add safe.directory "$PWD"
          opam install . --deps-only --with-test

      - name: Run unit tests with coverage
        run: |
          # Use tmpfs for fast I/O during test execution
          mkdir -p /dev/shm/coverage
          export BISECT_FILE=/dev/shm/coverage/bisect-unit
          
          # Set terminal environment for headless TUI tests
          export TERM=xterm-256color
          export TERMINFO=/usr/share/terminfo
          
          echo "=== Environment Check ==="
          echo "BISECT_FILE=$BISECT_FILE"
          echo "TERM=$TERM"
          df -h /dev/shm
          echo "Available memory:"
          free -h || echo "free command not available"
          echo "Process limits:"
          ulimit -a
          
          echo "=== Running tests with coverage (Debian container) ==="
          echo "Testing if Debian fixes UI regression test hang with bisect_ppx"
          
          # Debug: Check environment
          echo "PATH: $PATH"
          echo "OPAM_SWITCH_PREFIX: $OPAM_SWITCH_PREFIX"
          which dune || echo "dune not in PATH"
          which opam || echo "opam not in PATH"
          
          # Ensure opam environment is loaded
          eval $(opam env)
          echo "After eval opam env:"
          echo "PATH: $PATH"
          which dune || echo "dune STILL not in PATH"
          
          dune clean
          
          # Run ALL tests WITH instrumentation, but with timeout protection
          echo "Starting tests at $(date -u '+%H:%M:%S')"
          
          # Use timeout to prevent indefinite hangs (5 minutes should be more than enough)
          timeout 300 dune runtest --instrument-with bisect_ppx --force || {
            exit_code=$?
            if [ $exit_code -eq 124 ]; then
              echo "ERROR: Tests timed out after 5 minutes!"
              echo "This suggests the hang still occurs even with Debian."
              exit 1
            else
              echo "Tests failed with exit code $exit_code"
              exit $exit_code
            fi
          }
          
          echo "Completed at $(date -u '+%H:%M:%S')"
          
          echo ""
          echo "‚ö†Ô∏è  Coverage collection disabled due to CI hang issue"
          echo "Tests pass but coverage data not collected"
          echo "Run locally with: dune runtest --instrument-with bisect_ppx"
          
          # Copy coverage files to artifact location
          echo "=== Copying coverage data from tmpfs ==="
          mkdir -p _coverage
          cp -v /dev/shm/coverage/* _coverage/ || echo "Warning: No coverage files generated"
          ls -lah _coverage/
          echo "=== Coverage data ready for upload ==="
        continue-on-error: false

      - name: Upload unit coverage data
        uses: actions/upload-artifact@v4
        with:
          name: coverage-unit
          path: _coverage/
          retention-days: 1

  build-instrumented-binary:
    name: Build Instrumented Binary (Debian)
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/${{ github.repository }}-ci-debian:latest
      credentials:
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    env:
      OPAMYES: "true"
      MIAOU_GIT_URL: ${{ secrets.MIAOU_GIT_URL }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Cache opam packages
        id: cache-opam
        uses: actions/cache@v4
        with:
          path: /root/.opam
          key: opam-debian-miaou-${{ hashFiles('.github/miaou-version') }}
      
      - name: Ensure opam is initialized
        run: |
          # Check if opam actually works, not just if directory exists
          if opam switch list 2>&1 | grep -q "5.1.1"; then
            echo "Opam switch 5.1.1 exists, using it..."
            eval $(opam env)
          else
            echo "Initializing opam and creating switch 5.1.1..."
            opam init --disable-sandboxing --bare -y || true
            opam switch create 5.1.1 ocaml.5.1.1 -y
            eval $(opam env)
          fi
      
      - name: Pin miaou packages
        run: |
          if [ -z "$MIAOU_GIT_URL" ]; then
            echo "ERROR: MIAOU_GIT_URL secret is not configured." >&2
            exit 1
          fi
          eval $(opam env)
          opam pin add miaou-core "$MIAOU_GIT_URL" --no-action
          opam pin add miaou-driver-term "$MIAOU_GIT_URL" --no-action
          opam pin add miaou-driver-matrix "$MIAOU_GIT_URL" --no-action
          opam pin add miaou-runner "$MIAOU_GIT_URL" --no-action
          opam install miaou-core miaou-driver-term miaou-driver-matrix miaou-runner eio_posix
      
      - name: Install project dependencies
        run: |
          eval $(opam env)
          git config --global --add safe.directory "$PWD"
          opam install . --deps-only --with-test
      
      - name: Build instrumented static binary
        run: |
          # Build static binary for compatibility with Debian test container
          eval $(opam env)
          echo '(-ccopt -static)' > static_flags.sexp
          dune clean
          dune build --instrument-with bisect_ppx --release
          cp _build/default/src/main.exe octez-manager-instrumented
          chmod +x octez-manager-instrumented
          
          # Verify it's static
          ldd octez-manager-instrumented 2>&1 | head -10 || echo "Static binary confirmed"
      
      - name: Upload instrumented binary
        uses: actions/upload-artifact@v4
        with:
          name: octez-manager-coverage
          path: octez-manager-instrumented
          retention-days: 1

  integration-coverage:
    name: Integration Tests Coverage (Shard ${{ matrix.shard }})
    runs-on: ubuntu-latest
    needs: [coverage, build-instrumented-binary]
    # Run instrumented integration tests (with coverage) when:
    # 1. Pushing to main (always maintain coverage baseline), OR
    # 2. PR without 'skip-coverage' label (default behavior)
    # If PR has 'skip-coverage' label, fast tests run instead (see ci.yml)
    if: |
      github.event_name == 'push' ||
      (github.event_name == 'pull_request' && 
       !contains(github.event.pull_request.labels.*.name, 'skip-coverage'))
    timeout-minutes: 30
    strategy:
      fail-fast: false
      matrix:
        shard: [1, 2, 3, 4, 5]

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download instrumented binary
        uses: actions/download-artifact@v4
        with:
          name: octez-manager-coverage
          path: .

      - name: Copy binary to test location
        run: |
          mkdir -p test/integration/cli-tester
          cp octez-manager-instrumented test/integration/cli-tester/octez-manager
          chmod +x test/integration/cli-tester/octez-manager

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build coverage test containers
        working-directory: test/integration
        run: |
          docker compose -f docker-compose.yml -f docker-compose.coverage.yml build

      - name: Start sandbox
        working-directory: test/integration
        run: |
          docker compose -f docker-compose.yml -f docker-compose.coverage.yml up -d sandbox
          timeout 300 bash -c 'until docker compose exec -T sandbox curl -sf http://localhost:8080/health 2>/dev/null; do echo "Waiting for sandbox..."; sleep 10; done'

      - name: Start cli-tester with coverage
        working-directory: test/integration
        run: |
          docker compose -f docker-compose.yml -f docker-compose.coverage.yml up -d cli-tester
          echo "Waiting for systemd..."
          for i in {1..30}; do
            if docker compose exec -T cli-tester systemctl is-system-running 2>/dev/null; then
              echo "Systemd is ready"
              break
            fi
            echo "Attempt $i: systemd not ready yet..."
            sleep 2
          done
          docker compose ps

      - name: Run integration tests with coverage (Shard ${{ matrix.shard }})
        working-directory: test/integration
        env:
          SHARD: ${{ matrix.shard }}
          TOTAL_SHARDS: 5
        run: |
          docker compose -f docker-compose.yml -f docker-compose.coverage.yml exec -T -e SHARD -e TOTAL_SHARDS cli-tester /run-tests.sh

      - name: Extract coverage data from container
        working-directory: test/integration
        run: |
          mkdir -p ../../_coverage-integration
          docker compose -f docker-compose.yml -f docker-compose.coverage.yml cp cli-tester:/coverage/. ../../_coverage-integration/ || true
          ls -la ../../_coverage-integration/

      - name: Upload integration coverage data
        uses: actions/upload-artifact@v4
        with:
          name: coverage-integration-shard-${{ matrix.shard }}
          path: _coverage-integration/
          retention-days: 1

      - name: Cleanup containers
        if: always()
        working-directory: test/integration
        run: |
          docker compose -f docker-compose.yml -f docker-compose.coverage.yml down -v || true

  report:
    name: Generate and Post Coverage Report
    runs-on: ubuntu-latest
    needs: [coverage, build-instrumented-binary, integration-coverage]
    if: always() && needs.coverage.result == 'success'
    container:
      image: ghcr.io/${{ github.repository }}-ci:latest
      credentials:
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    env:
      OPAMYES: "true"
      OPAMROOT: /home/opam/.opam

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install bisect_ppx
        run: opam install bisect_ppx

      - name: Download unit coverage data
        uses: actions/download-artifact@v4
        with:
          name: coverage-unit
          path: _coverage/

      - name: Download integration coverage data (all shards)
        uses: actions/download-artifact@v4
        with:
          pattern: coverage-integration-shard-*
          path: _coverage/
          merge-multiple: true
        continue-on-error: true

      - name: List all coverage files
        run: |
          echo "Coverage files found:"
          find _coverage -name "*.coverage" -ls || echo "No coverage files found"

      - name: Generate coverage report
        run: |
          mkdir -p coverage-report
          
          echo "Generating coverage report..."
          echo "Total source files: $(find src -name "*.ml" -not -name "*_tests.ml" | wc -l)"
          
          # Generate summary
          echo "## Coverage Report" > coverage-summary.md
          echo "" >> coverage-summary.md
          
          echo "Running bisect-ppx-report summary..."
          bisect-ppx-report summary \
            --coverage-path _coverage > coverage-summary.txt 2>&1 || true
          
          echo "=== Coverage summary output ==="
          cat coverage-summary.txt
          echo "=== End coverage summary ==="
          
          cat coverage-summary.txt >> coverage-summary.md
          
          # Generate HTML report
          bisect-ppx-report html \
            --coverage-path _coverage \
            --title "Octez Manager Coverage" \
            -o coverage-report || echo "HTML generation failed"
          
          # Generate per-file summary
          echo "" >> coverage-summary.md
          echo "### Coverage by File" >> coverage-summary.md
          echo "" >> coverage-summary.md
          echo '```' >> coverage-summary.md
          bisect-ppx-report summary \
            --coverage-path _coverage \
            --per-file >> coverage-summary.md 2>&1 || true
          
          # Append files with no coverage (not instrumented or not executed)
          echo "" >> coverage-summary.md
          echo "### Files Not Covered (0%)" >> coverage-summary.md
          echo "" >> coverage-summary.md
          
          # Get list of all source files
          find src -name "*.ml" -not -name "*_tests.ml" | sort > /tmp/all_files.txt
          
          # Get list of files in coverage report
          grep -oE "src/[^[:space:]]+\.ml" coverage-summary.md | sort -u > /tmp/covered_files.txt || touch /tmp/covered_files.txt
          
          # Find files missing from coverage
          MISSING_COUNT=$(comm -23 /tmp/all_files.txt /tmp/covered_files.txt | wc -l)
          
          if [ "$MISSING_COUNT" -gt 0 ]; then
            echo "$MISSING_COUNT files with no coverage data:" >> coverage-summary.md
            comm -23 /tmp/all_files.txt /tmp/covered_files.txt | while read file; do
              echo "  0.00 %      0/0       $file" >> coverage-summary.md
            done
          else
            echo "All source files have coverage data!" >> coverage-summary.md
          fi
          
          echo '```' >> coverage-summary.md
          
          # Extract overall percentage from format: "Coverage: 6688/11735 (56.99%)"
          echo "Extracting coverage percentage..."
          if grep -q 'Coverage:' coverage-summary.txt; then
            # Extract percentage from parentheses: (XX.XX%)
            COVERAGE_PCT=$(grep 'Coverage:' coverage-summary.txt | sed 's/.*(\([0-9.]*\)%).*/\1/' | head -1)
          else
            # Fallback: look for any percentage pattern
            COVERAGE_PCT=$(grep -o '[0-9]\+\.[0-9]\+%' coverage-summary.txt | head -1 | tr -d '%')
          fi
          
          # If still empty, default to 0
          if [ -z "$COVERAGE_PCT" ]; then
            COVERAGE_PCT="0"
          fi
          
          echo "COVERAGE_PCT=$COVERAGE_PCT" >> $GITHUB_ENV
          echo "Overall coverage: $COVERAGE_PCT%"

      - name: Get base branch coverage (for PRs)
        if: github.event_name == 'pull_request'
        run: |
          # Try to get base coverage from previous runs
          # For now, we'll store it in the summary
          echo "BASE_COVERAGE=0" >> $GITHUB_ENV
        continue-on-error: true

      - name: Comment PR with coverage
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const coverage = process.env.COVERAGE_PCT || '0';
            const baseCoverage = process.env.BASE_COVERAGE || '0';
            const diff = (parseFloat(coverage) - parseFloat(baseCoverage)).toFixed(2);
            
            let emoji = 'üìä';
            let diffText = '';
            let diffColor = '';
            
            if (diff > 0) {
              emoji = 'üìà';
              diffText = `(+${diff}%)`;
              diffColor = 'üü¢';
            } else if (diff < 0) {
              emoji = 'üìâ';
              diffText = `(${diff}%)`;
              diffColor = 'üî¥';
            } else {
              diffText = '(no change)';
              diffColor = '‚ö™';
            }
            
            let summary = '';
            try {
              summary = fs.readFileSync('coverage-summary.md', 'utf8');
            } catch (e) {
              summary = 'Coverage report not available';
            }
            
            const comment = `## ${emoji} Coverage Report
            
            **Overall Coverage:** ${coverage}% ${diffColor} ${diffText}
            
            ${summary}
            
            <details>
            <summary>‚ÑπÔ∏è Coverage Details</summary>
            
            - **Unit Tests:** ‚úÖ Instrumented with bisect_ppx
            - **Integration Tests:** ‚úÖ Instrumented with bisect_ppx
            - **Report Type:** Combined coverage from both test suites
            
            </details>
            `;
            
            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
            });
            
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && comment.body.includes('Coverage Report')
            );
            
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: comment
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: comment
              });
            }

      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: coverage-report/
          retention-days: 30

      - name: Coverage check
        run: |
          COVERAGE_PCT=$(grep -oP 'Coverage: \K[0-9.]+' coverage-summary.txt || echo "0")
          echo "Coverage: $COVERAGE_PCT%"
          
          # Fail if coverage drops below threshold (optional)
          # THRESHOLD=50
          # if (( $(echo "$COVERAGE_PCT < $THRESHOLD" | bc -l) )); then
          #   echo "ERROR: Coverage $COVERAGE_PCT% is below threshold $THRESHOLD%"
          #   exit 1
          # fi
