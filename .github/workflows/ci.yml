name: CI

on:
  push:
    branches: [main]
    tags:
      - 'v*'
    paths-ignore:
      - 'docs/**'
      - '**/*.md'
  pull_request:
    branches: [main]
    paths-ignore:
      - 'docs/**'
      - '**/*.md'
  workflow_dispatch:

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

jobs:
  changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    outputs:
      needs-integration: ${{ steps.filter.outputs.needs-integration }}
    steps:
      - uses: actions/checkout@v4
      - uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            needs-integration:
              - 'src/**'
              - '!src/ui/**'
              - 'test/integration/**'
              - '.github/workflows/ci.yml'
              - 'Makefile'

  build-and-test:
    name: Build and Test
    needs: changes
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/${{ github.repository }}-ci:latest
      credentials:
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    env:
      OPAMYES: "true"
      OPAMROOT: /home/opam/.opam
      MIAOU_GIT_URL: ${{ secrets.MIAOU_GIT_URL }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Cache opam packages
        id: cache-opam
        uses: actions/cache@v4
        with:
          path: /home/opam/.opam
          key: opam-miaou-${{ hashFiles('.github/miaou-version') }}

      - name: Pin miaou packages
        if: steps.cache-opam.outputs.cache-hit != 'true'
        run: |
          if [ -z "$MIAOU_GIT_URL" ]; then
            echo "ERROR: MIAOU_GIT_URL secret is not configured." >&2
            exit 1
          fi
          opam pin add miaou-core "$MIAOU_GIT_URL" --no-action
          opam pin add miaou-driver-term "$MIAOU_GIT_URL" --no-action
          opam pin add miaou-driver-matrix "$MIAOU_GIT_URL" --no-action
          opam pin add miaou-runner "$MIAOU_GIT_URL" --no-action
          opam install miaou-core miaou-driver-term miaou-driver-matrix miaou-runner eio_posix

      - name: Cache dune build
        uses: actions/cache@v4
        with:
          path: _build
          key: dune-${{ runner.os }}-${{ hashFiles('src/**', 'dune-project') }}
          restore-keys: |
            dune-${{ runner.os }}-

      - name: Check copyright headers
        run: |
          echo "Checking copyright headers..."
          ./scripts/check-copyright.sh

      - name: Install bisect_ppx for coverage
        run: |
          opam install -y bisect_ppx

      - name: Build
        run: |
          echo '(-ccopt -static)' > static_flags.sexp
          dune build --release

      - name: Test
        run: |
          chown -R opam:opam /home/opam/.opam
          chown -R opam:opam .
          mkdir -p _coverage/unit
          chown -R opam:opam _coverage
          su -s /bin/sh opam -c "export BISECT_FILE=${{ github.workspace }}/_coverage/unit/bisect && git checkout -- static_flags.sexp && dune runtest --instrument-with bisect_ppx"

      - name: Debug coverage files
        run: |
          echo "=== Coverage directory contents ==="
          ls -laR _coverage/ || echo "No _coverage directory"
          echo "=== Looking for .coverage files ==="
          find . -name "*.coverage" -ls || echo "No .coverage files found"

      - name: Prepare binary artifact
        run: |
          mkdir -p artifacts
          cp _build/default/src/main.exe artifacts/octez-manager
          chmod +x artifacts/octez-manager

      - name: Upload binary artifact
        uses: actions/upload-artifact@v4
        with:
          name: octez-manager-static
          path: artifacts/octez-manager
          retention-days: 1

      - name: Upload unit test coverage data
        uses: actions/upload-artifact@v4
        with:
          name: coverage-unit
          path: _coverage/unit/bisect*.coverage
          retention-days: 1
          if-no-files-found: warn

  coverage:
    name: Code Coverage Report
    needs: [build-and-test]
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/${{ github.repository }}-ci:latest
      credentials:
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    env:
      OPAMYES: "true"
      OPAMROOT: /home/opam/.opam

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install bisect_ppx
        run: |
          opam install -y bisect_ppx

      - name: Download unit test coverage
        uses: actions/download-artifact@v4
        with:
          name: coverage-unit
          path: _coverage/merged/

      - name: Generate merged coverage report
        run: |
          mkdir -p _coverage/html
          # Find all coverage files
          COVERAGE_FILES=$(find _coverage/merged -name '*.coverage' -print)
          if [ -z "$COVERAGE_FILES" ]; then
            echo "ERROR: No coverage files found!"
            exit 1
          fi
          echo "Found coverage files:"
          echo "$COVERAGE_FILES"
          # Generate reports
          bisect-ppx-report summary --per-file $COVERAGE_FILES | tee _coverage/summary.txt
          bisect-ppx-report html -o _coverage/html $COVERAGE_FILES

      - name: Generate coverage summary
        id: coverage
        run: |
          # Extract overall coverage percentage
          COVERAGE=$(grep "Project coverage" _coverage/summary.txt | awk '{print $1}')
          echo "coverage=$COVERAGE" >> $GITHUB_OUTPUT
          echo "## Coverage Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Overall Coverage: $COVERAGE**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Per-file Coverage" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          cat _coverage/summary.txt >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: |
            _coverage/summary.txt
            _coverage/html/
          retention-days: 30

      - name: Comment coverage on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const summary = fs.readFileSync('_coverage/summary.txt', 'utf8');
            const lines = summary.split('\n');
            const projectLine = lines.find(l => l.includes('Project coverage'));
            const coverage = projectLine ? projectLine.trim().split(/\s+/)[0] : 'Unknown';
            
            // Get per-file coverage
            const fileLines = lines.filter(l => l.trim() && !l.includes('Project coverage'));
            const lowCoverage = fileLines.filter(l => {
              const percent = parseFloat(l.trim().split(/\s+/)[0]);
              return !isNaN(percent) && percent < 50;
            }).slice(0, 10); // Top 10 files with low coverage
            
            let body = `## üìä Coverage Report\n\n`;
            body += `**Overall Coverage: ${coverage}**\n\n`;
            
            if (lowCoverage.length > 0) {
              body += `### ‚ö†Ô∏è Files with Low Coverage (<50%)\n\n`;
              body += '```\n';
              body += lowCoverage.join('\n');
              body += '\n```\n\n';
            }
            
            body += `<details>\n<summary>üìã Full Coverage Report</summary>\n\n\`\`\`\n${summary}\n\`\`\`\n</details>\n\n`;
            body += `[View detailed HTML report](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})`;
            
            // Find existing coverage comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('üìä Coverage Report')
            );
            
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }

  integration-tests:
    name: Integration Tests (${{ matrix.category }})
    runs-on: ubuntu-latest
    needs: [changes, build-and-test]
    if: needs.changes.outputs.needs-integration == 'true'
    timeout-minutes: 20
    strategy:
      fail-fast: false
      matrix:
        category: [node, dal, baker, accuser]

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download static binary
        uses: actions/download-artifact@v4
        with:
          name: octez-manager-static
          path: test/integration/cli-tester/

      - name: Prepare test binary
        run: |
          chmod +x test/integration/cli-tester/octez-manager

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver: docker-container

      - name: Build and start containers
        working-directory: test/integration
        env:
          DOCKER_BUILDKIT: 1
        run: |
          # Build with cache and start
          docker compose up -d --build

          # Wait for sandbox to be healthy
          echo "Waiting for sandbox..."
          timeout 300 bash -c 'until docker compose exec -T sandbox curl -sf http://localhost:8080/health 2>/dev/null; do sleep 5; done'
          echo "Sandbox is ready"

          # Wait for systemd to be ready
          echo "Waiting for systemd..."
          for i in {1..30}; do
            if docker compose exec -T cli-tester systemctl is-system-running 2>/dev/null; then
              echo "Systemd is ready"
              break
            fi
            sleep 2
          done

      - name: Run integration tests (${{ matrix.category }})
        working-directory: test/integration
        run: |
          docker compose exec -T cli-tester /run-tests.sh ${{ matrix.category }}

      - name: Collect logs on failure
        if: failure()
        working-directory: test/integration
        run: |
          echo "=== Sandbox logs ==="
          docker compose logs sandbox || true
          echo "=== CLI-tester logs ==="
          docker compose logs cli-tester || true

      - name: Cleanup
        if: always()
        working-directory: test/integration
        run: |
          docker compose down -v || true

  release:
    name: Release
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v')
    needs: build-and-test
    permissions:
      contents: write
    container:
      image: ghcr.io/${{ github.repository }}-ci:latest
      credentials:
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    env:
      OPAMYES: "true"
      OPAMROOT: /home/opam/.opam
      MIAOU_GIT_URL: ${{ secrets.MIAOU_GIT_URL }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Cache opam packages
        id: cache-opam
        uses: actions/cache@v4
        with:
          path: /home/opam/.opam
          key: opam-miaou-${{ hashFiles('.github/miaou-version') }}

      - name: Pin miaou packages
        if: steps.cache-opam.outputs.cache-hit != 'true'
        run: |
          opam pin add miaou-core "$MIAOU_GIT_URL" --no-action
          opam pin add miaou-driver-term "$MIAOU_GIT_URL" --no-action
          opam pin add miaou-driver-matrix "$MIAOU_GIT_URL" --no-action
          opam pin add miaou-runner "$MIAOU_GIT_URL" --no-action
          opam install miaou-core miaou-driver-term miaou-driver-matrix miaou-runner eio_posix

      - name: Build static binary
        run: |
          echo '(-ccopt -static)' > static_flags.sexp
          dune build --release

      - name: Prepare release artifact
        run: |
          mkdir -p release
          cp _build/default/src/main.exe release/octez-manager-${{ github.ref_name }}-linux-x86_64
          chmod +x release/octez-manager-${{ github.ref_name }}-linux-x86_64

      - name: Upload binary for packaging jobs
        uses: actions/upload-artifact@v4
        with:
          name: release-binary
          path: release/octez-manager-${{ github.ref_name }}-linux-x86_64
          retention-days: 1

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          files: release/octez-manager-${{ github.ref_name }}-linux-x86_64
          generate_release_notes: true

  package-ubuntu:
    name: Package (.deb Ubuntu)
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v')
    needs: release
    permissions:
      contents: write

    steps:
      - name: Download binary
        uses: actions/download-artifact@v4
        with:
          name: release-binary
          path: bin

      - name: Install fpm
        run: |
          sudo apt-get update
          sudo apt-get install -y ruby ruby-dev rubygems build-essential
          sudo gem install fpm

      - name: Extract version
        id: version
        run: echo "version=${GITHUB_REF_NAME#v}" >> $GITHUB_OUTPUT

      - name: Build Ubuntu .deb package
        run: |
          chmod +x bin/octez-manager-*
          fpm -s dir -t deb \
            -n octez-manager \
            -v ${{ steps.version.outputs.version }} \
            --architecture amd64 \
            --description "CLI and TUI for managing Tezos infrastructure" \
            --url "https://github.com/trilitech/octez-manager" \
            --license "MIT" \
            --maintainer "Nomadic Labs <contact@nomadic-labs.com>" \
            --vendor "Nomadic Labs" \
            --category "utils" \
            --deb-priority optional \
            --deb-dist stable \
            bin/octez-manager-${{ github.ref_name }}-linux-x86_64=/usr/local/bin/octez-manager
          mv *.deb octez-manager_${{ steps.version.outputs.version }}_ubuntu_amd64.deb

      - name: Upload to release
        uses: softprops/action-gh-release@v2
        with:
          files: octez-manager_${{ steps.version.outputs.version }}_ubuntu_amd64.deb

  package-debian:
    name: Package (.deb Debian)
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v')
    needs: release
    permissions:
      contents: write
    container:
      image: debian:bookworm

    steps:
      - name: Install dependencies
        run: |
          apt-get update
          apt-get install -y ruby ruby-dev rubygems build-essential curl

      - name: Download binary
        uses: actions/download-artifact@v4
        with:
          name: release-binary
          path: bin

      - name: Install fpm
        run: gem install fpm

      - name: Extract version
        id: version
        run: echo "version=${GITHUB_REF_NAME#v}" >> $GITHUB_OUTPUT

      - name: Build Debian .deb package
        run: |
          chmod +x bin/octez-manager-*
          fpm -s dir -t deb \
            -n octez-manager \
            -v ${{ steps.version.outputs.version }} \
            --architecture amd64 \
            --description "CLI and TUI for managing Tezos infrastructure" \
            --url "https://github.com/trilitech/octez-manager" \
            --license "MIT" \
            --maintainer "Nomadic Labs <contact@nomadic-labs.com>" \
            --vendor "Nomadic Labs" \
            --category "utils" \
            --deb-priority optional \
            --deb-dist bookworm \
            bin/octez-manager-${{ github.ref_name }}-linux-x86_64=/usr/local/bin/octez-manager
          mv *.deb octez-manager_${{ steps.version.outputs.version }}_debian_amd64.deb

      - name: Upload to release
        uses: softprops/action-gh-release@v2
        with:
          files: octez-manager_${{ steps.version.outputs.version }}_debian_amd64.deb
